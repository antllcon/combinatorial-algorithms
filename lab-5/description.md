# Лабораторная работа 4

## [# 100] Генетический алгоритм для задачи покрытия множества.

Дано:
- Универсум элементов U = {e₁, e₂, ..., eₘ}
- Семейство подмножеств S = {S₁, S₂, ..., Sₙ}, где Sⱼ ⊆ U
- Стоимости подмножеств cⱼ > 0 для каждого Sⱼ

Требуется найти минимальное по стоимости покрытие C ⊆ S, такое что:
⋃_{Sⱼ∈C} Sⱼ = U

### Требуется реализовать:

1. **Класс `GeneticSetCoverSolver`** со следующими методами:
   - `initialize_population()`: создает начальную популяцию случайных решений
   - `repair_solution(vector<bool>&)`: восстанавливает допустимость решения
   - `crossover(const vector<bool>&, const vector<bool>&)`: оператор кроссовера
   - `mutate(vector<bool>&)`: оператор мутации с переменной вероятностью
   - `solve()`: основной метод решения задачи

2. **Функцию оценки качества**:
`double calculate_cost(const vector<bool>& solution)`
   Возвращает суммарную стоимость выбранных подмножеств.

3. **Функцию проверки допустимости**:
`bool is_feasible(const vector<bool>& solution)`
   Проверяет, покрывают ли выбранные подмножества все элементы универсума.

### Особые требования:
- Использовать улучшенный оператор кроссовера, учитывающий частоты генов
- Реализовать мутацию на основе энтропии генов в популяции
- Включить жадный алгоритм восстановления допустимости решений
- Поддержать чтение входных данных в формате OR-Library

### Входные данные:
Матрица принадлежности элементов к подмножествам и вектор стоимостей подмножеств.

### Выходные данные:
Вектор булевых значений, указывающих какие подмножества включены в решение, и стоимость этого решения.