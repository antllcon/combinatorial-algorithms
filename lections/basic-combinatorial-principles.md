# Основные комбинаторные принципы
## Комбинаторика
### Определение
`Комбинаторика` - раздел дискретной математики, ориентированный на решение задач выбора и расположения элементов некоторого множества в соответствии с заданными правилами и ограничениями.

Каждое такое правило определяет способ построения некоторой комбинаторной конфигурации, поэтому комбинаторика занимается:
1. Изучением свойств комбинаторных конфигураций
2. Условиями их существования
3. Алгоритмами построения комбинаторных конфигураций
4. Оптимизацией этих алгоритмов

### Две основные задачи комбинаторики
1. Подсчёт комбинаций
2. Генерация комбинаторных объектов

### Правила комбинаторики
1. Правило суммы
2. Правило произведения 
Принцип Дирихле

### Основные комбинаторные конфигурации
1. Размещения
Две расстановки считаются различными, если они отличаются видом входящих в них элементов или порядком их в расстановке.
Такие расстановки называются `размещениями без повторений`.

#### Пример - размещения без повторений
```
Множество состоит из 17 разных элементов. Выбираются 3 элемента с учётом порядка.
1. Сколькими способами могут быть выбраны 3 элемента?
2. Сгенерировать всевозможные способы выбора трёх элементов.
```
### Перестановки
При составлении размещений без повторений из п по k мы получали расстановки, отличающиеся друг от друга либо составом, либо порядком элементов.
Но если брать расстановки, которые включают все п элементов, то они могут отличаться друг от друга лишь порядком входящих в них элементов.
Такие расстановки называются `перестановками` из n элементов.

#### Пример - перестановки
```
Множество состоит из 8 элементов. Выбираются все 8 элементов с учётом порядка.
1. Сколькими способами мы можем это сделать?
Сгенерировать всевозможные способы выбора 8 элементов.
```

### Сочетания
В тех случаях, когда нас не интересует порядок элементов в расстановке, а интересует лишь её состав, то говорят о сочетаниях.
Сочетаниями из п различных элементов по k называют все возможные расстановки длины k, образованные из этих элементов и отличающиеся друг от друга составом, но не порядком элементов.

#### Пример - сочетания
```
Множество состоит их 14 элементов. Мы составляем всевозможные подмножества мощности 3.
1. Сколькими способами мы можем это сделать?
2. Сгенерировать всевозможные подмножества.
```

## Генерация комбинаторных объектов
### Порождение комбинаторных объектов
Все рассматриваемые методы систематического порождения комбинаторных объектов будут сводиться:
1. К выбору начальной конфигурации, задающей первый генерируемый объект. Трансформации полученного объекта в следующий.
2. Проверке условия окончания, которое определяет момент прекращения вычислений.

При этом особый интерес будут представлять алгоритмы генерации объектов в порядке `минимального изменения`, когда два «соседних» порождаемых объекта различаются в подходящем смысле «минимально».

### Лексикографический порядок
`Лексико-графический порядок` — это способ упорядочивания слов или строк по алфавиту, когда символы сравниваются последовательно, начиная с первого, и ранжируются согласно их позиции в алфавите. Если первые символы совпадают, сравнение продолжается со следующими.

Удволетворяет следующим аксиомам:
1. Рефлексивность
2. Антисиметричность
3. Транзитивность
4. Сравнимость

#### Пример лексикографической последовательности
```
123, 132 213 231 312 321
```

### Генерация перестановок в лексикографическом порядке
Алгоритм Нараяны генерирует перестановки в лексикографическом порядке следующим образом:

1. **Начало**: Стартуем с тождественной перестановки (1, 2, ..., n).
2. **Поиск и замена**:
   - Находим наибольший индекс `i`, такой что `α[i] < α[i+1]`.
   - Если такого `i` нет, алгоритм завершается.
   - Находим наибольший индекс `j`, такой что `α[j] > α[i]`.
   - Меняем местами `α[i]` и `α[j]`.
3. **Реверс подпоследовательности**: Разворачиваем подпоследовательность от `α[i+1]` до конца.
4. **Повторение**: Повторяем шаги 2-3 до получения перестановки (n, n-1, ..., 2, 1).

Этот процесс обеспечивает генерацию всех перестановок в лексикографическом порядке.

#### Пример - использование алгоритма Нараяны
```c++
#include <algorithm>
#include <iostream>
#include <vector>
#include <boost/timer.hpp>

int main()
{
	std::vector<size_t> v = { 7, 1, 12, 5, 9, 20, 15 };
	boost::timer t;
	t.restart();
	std::sort(v.begin(), v.end());
	do
	{
		copy(v.begin(), v.end(), std::ostream_iterator<size_t>(std::cout, " "));
		std::cout << std::endl;
	} while (std::next_permutation(v.begin(), v.end()));
	double duration = t.elapsed();

	std::cout << duration << std::endl;
}
```

### Эффективное порождение перестановок
Алгоритм Джонсона-Троттера — это метод генерации всех перестановок множества в таком порядке, что каждая следующая перестановка отличается от предыдущей только одной транспозицией (перестановкой двух соседних элементов). Алгоритм работает следующим образом:

1. **Инициализация**: Начинаем с перестановки (1, 2, ..., n) и присваиваем каждому элементу направление движения: все элементы двигаются влево.

2. **Поиск активного элемента**:
   - Находим наибольший активный элемент, который может переместиться в соответствии со своим направлением. Активным считается элемент, который может поменяться местами со своим соседом без нарушения порядка.
   - Если такой элемент не найден, алгоритм завершается.

3. **Перемещение активного элемента**:
   - Перемещаем найденный активный элемент в указанном направлении, меняясь местами с соседним элементом.
   - Изменяем направление движения для всех больших элементов, которые находятся между старой и новой позициями активного элемента.

4. **Повторение**: Повторяем шаги 2-3 до тех пор, пока не будут сгенерированы все возможные перестановки.

Этот алгоритм обеспечивает эффективное и систематическое перебор всех перестановок множества, при этом каждая следующая перестановка отличается от предыдущей минимальным изменением.

### Порождение случайных перестановок
Нужен метод, тасующий карточную колоду. Колода должна быть идеально перемешана. Перестановки карт должны быть равновероятными. Вы можете использовать идеальный генератор случайных чисел.